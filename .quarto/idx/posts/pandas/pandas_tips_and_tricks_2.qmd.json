{"title":"Lost in Pandas - Part 2","markdown":{"yaml":{"title":"Lost in Pandas - Part 2","author":"Nodar Okroshiashvili","date":"2020-04-14","categories":["Data Science"],"tags":["Pandas","Data Analysis"],"keywords":["pandas","python","data analysis","pandas tips and tricks","advance pandas","data transformation in pandas"]},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n\nI will show you how to fill missing values by the average of its before and after values if our dataframe has the following form:\n\n## Problem Statement\n\nHow can we perform ```groupby``` and fill ```Nan```'s with its preceding and following values?\n\n```{python}\n\nimport pandas as pd\nimport numpy as np\n\n```\n\n```{python}\n\ndata = {\n    \"type\": [\n        \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\",\n        \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\",\n    ],\n    \"date\": [\n        \"2018-09\", \"2018-10\", \"2018-11\", \"2018-12\", \"2019-01\", \"2019-02\", \"2019-03\",\n        \"2019-04\", \"2019-05\", \"2019-06\", \"2019-07\", \"2019-08\", \"2019-09\", \"2019-10\",\n        \"2019-11\", \"2018-09\", \"2018-10\", \"2018-11\", \"2018-12\", \"2019-01\", \"2019-02\",\n        \"2019-03\", \"2019-04\", \"2019-05\", \"2019-06\", \"2019-07\", \"2019-08\", \"2019-09\",\n        \"2019-10\", \"2019-11\",\n    ],\n    \"v1\": [\n        10, np.nan, np.nan, 20, np.nan, np.nan, 30, np.nan, np.nan, 40, np.nan,\n        np.nan, 50, np.nan, np.nan, 60, np.nan, np.nan, 70, np.nan, np.nan, 80,\n        np.nan, np.nan, 90, np.nan, np.nan, 100, np.nan, np.nan,\n    ],\n    \"v2\": [\n        10, np.nan, np.nan, 20, np.nan, np.nan, 30, np.nan, np.nan, 40, np.nan,\n        np.nan, 50, np.nan, np.nan, 60, np.nan, np.nan, 70, np.nan, np.nan, 80,\n        np.nan, np.nan, 90, np.nan, np.nan, 100, np.nan, np.nan,\n    ],\n}\n\n\ndf = pd.DataFrame(data)\n\ndf.head()\n\n```\n\nWe see that values in ```type``` and ```date``` column are repetitive. Moreover, it does not matter what values are in other two columns, unless it is numeric type. Our aim is to fill these missing values by the average of its before and after value for ```v1``` and ```v2``` columns. We also notice that sorting and then filling won't give desired result. We need something different. But before we find that solution we need to convert columns in numeric type in order to compute average by using Pandas ```to_numeric()``` method with parameter \"errors\" set to \"coerce\", because Pandas DataFrame ```astype()``` method won't work in this case.\n\nWe have two solution here. To use both of them let make copy of initial dataframe. The first uses ```groupby``` and then applies aggregator with \"backward fill\" and \"forward fill\" and then again ```groupby``` and then computes mean. The second solution does almost the same as the first but uses ```apply()``` method instead of aggregation.\n\n```{python}\n\n# The first solution\n\ndf_first = df.copy(deep=True)\n\ndf_first[[\"v1\", \"v2\"]] = (df_first.groupby(\"type\")[[\"v1\", \"v2\"]]\n                                  .agg([\"bfill\", \"ffill\"])\n                                  .groupby(level=0, axis=1)\n                                  .mean())\n\ndf_first\n\n```\n\n```{python}\n\n# The second solution\n\ndf_second = df.copy(deep=True)\n\ng = df_second.groupby([\"type\"], group_keys=False)[[\"v1\", \"v2\"]]\n\ndf_second[[\"v1\", \"v2\"]] = (g.ffill() + g.bfill()) / 2\n\ndf_second[[\"v1\", \"v2\"]] = g.apply(lambda x: x.bfill().ffill())\n\n\ndf_second\n\n```\n\nAbove two methods gave us desirable results. Let try some plain method to achieve the same. Below is the dry, plain method which fill missing values by  backward and forward average. However by using this we introduce bug which will be hard to detect. Let see.\n\n```{python}\n\n# The third method\n\ndf_third = df.copy(deep=True)\n\ndf_third[[\"v1\", \"v2\"]] = (df_third[[\"v1\", \"v2\"]].ffill() + df_third[[\"v1\", \"v2\"]].bfill()) / 2\n\ndf_third[[\"v1\", \"v2\"]] = df_third[[\"v1\", \"v2\"]].bfill().ffill()\n\ndf_third\n\n```\n\nAt the first glance everything seems ok, but let check the equality of these three dataframes with double equality sign and ```all``` method.\n\n```{python}\n\ndf_first == df_second\n\n# The result of the first and the second method are equal\n\n```\n\n```{python}\n\ndf_third == df_first\n\n```\n\nAt index position 13 and 14 we have ```False``` values. That was the reason of inequality. But why do we have these ```False``` values? The dry plain method calculated the average of non-missing values sequentially not by ```type```. At index 13 and 14 the average is 50 not 55, because the third method calculated the average between 50 and 60 instead of 50 and NaN. That resulted the bug!\n\n```{python}\n\ndf.iloc[12:16]\n\n```\n\n```{python}\n\ndf_first.iloc[12:16]\n\n```\n\n```{python}\n\ndf_third.iloc[12:16]  # Not Correct\n\n```\n","srcMarkdownNoYaml":"\n\n# Introduction\n\nI will show you how to fill missing values by the average of its before and after values if our dataframe has the following form:\n\n## Problem Statement\n\nHow can we perform ```groupby``` and fill ```Nan```'s with its preceding and following values?\n\n```{python}\n\nimport pandas as pd\nimport numpy as np\n\n```\n\n```{python}\n\ndata = {\n    \"type\": [\n        \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\",\n        \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\",\n    ],\n    \"date\": [\n        \"2018-09\", \"2018-10\", \"2018-11\", \"2018-12\", \"2019-01\", \"2019-02\", \"2019-03\",\n        \"2019-04\", \"2019-05\", \"2019-06\", \"2019-07\", \"2019-08\", \"2019-09\", \"2019-10\",\n        \"2019-11\", \"2018-09\", \"2018-10\", \"2018-11\", \"2018-12\", \"2019-01\", \"2019-02\",\n        \"2019-03\", \"2019-04\", \"2019-05\", \"2019-06\", \"2019-07\", \"2019-08\", \"2019-09\",\n        \"2019-10\", \"2019-11\",\n    ],\n    \"v1\": [\n        10, np.nan, np.nan, 20, np.nan, np.nan, 30, np.nan, np.nan, 40, np.nan,\n        np.nan, 50, np.nan, np.nan, 60, np.nan, np.nan, 70, np.nan, np.nan, 80,\n        np.nan, np.nan, 90, np.nan, np.nan, 100, np.nan, np.nan,\n    ],\n    \"v2\": [\n        10, np.nan, np.nan, 20, np.nan, np.nan, 30, np.nan, np.nan, 40, np.nan,\n        np.nan, 50, np.nan, np.nan, 60, np.nan, np.nan, 70, np.nan, np.nan, 80,\n        np.nan, np.nan, 90, np.nan, np.nan, 100, np.nan, np.nan,\n    ],\n}\n\n\ndf = pd.DataFrame(data)\n\ndf.head()\n\n```\n\nWe see that values in ```type``` and ```date``` column are repetitive. Moreover, it does not matter what values are in other two columns, unless it is numeric type. Our aim is to fill these missing values by the average of its before and after value for ```v1``` and ```v2``` columns. We also notice that sorting and then filling won't give desired result. We need something different. But before we find that solution we need to convert columns in numeric type in order to compute average by using Pandas ```to_numeric()``` method with parameter \"errors\" set to \"coerce\", because Pandas DataFrame ```astype()``` method won't work in this case.\n\nWe have two solution here. To use both of them let make copy of initial dataframe. The first uses ```groupby``` and then applies aggregator with \"backward fill\" and \"forward fill\" and then again ```groupby``` and then computes mean. The second solution does almost the same as the first but uses ```apply()``` method instead of aggregation.\n\n```{python}\n\n# The first solution\n\ndf_first = df.copy(deep=True)\n\ndf_first[[\"v1\", \"v2\"]] = (df_first.groupby(\"type\")[[\"v1\", \"v2\"]]\n                                  .agg([\"bfill\", \"ffill\"])\n                                  .groupby(level=0, axis=1)\n                                  .mean())\n\ndf_first\n\n```\n\n```{python}\n\n# The second solution\n\ndf_second = df.copy(deep=True)\n\ng = df_second.groupby([\"type\"], group_keys=False)[[\"v1\", \"v2\"]]\n\ndf_second[[\"v1\", \"v2\"]] = (g.ffill() + g.bfill()) / 2\n\ndf_second[[\"v1\", \"v2\"]] = g.apply(lambda x: x.bfill().ffill())\n\n\ndf_second\n\n```\n\nAbove two methods gave us desirable results. Let try some plain method to achieve the same. Below is the dry, plain method which fill missing values by  backward and forward average. However by using this we introduce bug which will be hard to detect. Let see.\n\n```{python}\n\n# The third method\n\ndf_third = df.copy(deep=True)\n\ndf_third[[\"v1\", \"v2\"]] = (df_third[[\"v1\", \"v2\"]].ffill() + df_third[[\"v1\", \"v2\"]].bfill()) / 2\n\ndf_third[[\"v1\", \"v2\"]] = df_third[[\"v1\", \"v2\"]].bfill().ffill()\n\ndf_third\n\n```\n\nAt the first glance everything seems ok, but let check the equality of these three dataframes with double equality sign and ```all``` method.\n\n```{python}\n\ndf_first == df_second\n\n# The result of the first and the second method are equal\n\n```\n\n```{python}\n\ndf_third == df_first\n\n```\n\nAt index position 13 and 14 we have ```False``` values. That was the reason of inequality. But why do we have these ```False``` values? The dry plain method calculated the average of non-missing values sequentially not by ```type```. At index 13 and 14 the average is 50 not 55, because the third method calculated the average between 50 and 60 instead of 50 and NaN. That resulted the bug!\n\n```{python}\n\ndf.iloc[12:16]\n\n```\n\n```{python}\n\ndf_first.iloc[12:16]\n\n```\n\n```{python}\n\ndf_third.iloc[12:16]  # Not Correct\n\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"pandas_tips_and_tricks_2.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.23","theme":["flatly"],"title-block-banner":true,"comments":{"giscus":{"repo":"Okroshiashvili/okrodata","reactions-enabled":true,"input-position":"bottom","theme":"light","language":"en","loading":"lazy"}},"title":"Lost in Pandas - Part 2","author":"Nodar Okroshiashvili","date":"2020-04-14","categories":["Data Science"],"tags":["Pandas","Data Analysis"],"keywords":["pandas","python","data analysis","pandas tips and tricks","advance pandas","data transformation in pandas"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}