{
  "hash": "f9b1007786a0dfd7795b30aa67349491",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Integer Sequences in Python\"\nauthor: \"Nodar Okroshiashvili\"\ndate: \"2020-12-23\"\ncategories: [Mathematics]\ntags: [Number Theory, Python, Sequences]\nkeywords: [integer sequences with python, number theory, plot sequences in python, mathematical plotting in python, fibonacci sequence in python, factorial in python]\n---\n\n# Introduction\n\nIn this article, I want to review some integer sequences from [number theory](https://en.wikipedia.org/wiki/Number_theory). \nParticularly, I will review their mathematical formulation, then will write Python functions for them and later on generate \nsequences to visualize them.\n\nIn short, **integer sequence** is an ordered list of integers. Generally, in mathematics, the sequence is a collection of objects, \nwhere repetition is allowed, and object order does not matter. The number of objects a.k.a elements is the length of the sequence. \nThe sequence can be finite or infinite, increasing or decreasing, convergent or divergent, bounded or unbounded.\n\nA sequence generally has a **rule**, which indicates how we can find the value of each element. An integer sequence \ncan be declared either by the formula for its $n^{th}$ element, or by giving the relationship between its elements. \nMoreover, sequences have the initial condition, which gives us the value of the first few terms of the sequence.\n\n::: {#64bfb3f7 .cell execution_count=1}\n``` {.python .cell-code}\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nplt.style.use(\"ggplot\")\n```\n:::\n\n\n::: {#c50e9a99 .cell execution_count=2}\n``` {.python .cell-code}\ndef plot_sequence(sequence, x_range, title, x_label, y_label):\n    \"\"\"\n    Plot a sequence of integers.\n\n    Args:\n        sequence: Sequence of integers.\n        title: Title of the plot.\n        x_label: Label of the x-axis.\n        y_label: Label of the y-axis.\n    \"\"\"\n    plt.figure(figsize=(10, 6))\n    ax = sns.barplot(x=list(range(x_range)), y=sequence)\n    ax.set_title(title)\n    ax.set_xlabel(x_label)\n    ax.set_ylabel(y_label)\n    plt.plot(sequence, linewidth=4, color=\"black\")\n    plt.show()\n```\n:::\n\n\n### Fibonacci Sequence\n\nLet first review the well-known **[Fibonacci Sequence](https://en.wikipedia.org/wiki/Fibonacci_number)**. In the sequence \neach element is the sum of the two preceding elements starting from $0$ and $1$. The sequence is commonly denoted by $F_{n}$ and \nthe initial condition is given as: $F_{0} = 0$ and $F_{1} = 1$.\nThe general formula is: \n$$\nF_{n} = F_{n-1} + F_{n - 2} \\ \\ \\ \\ \\ \\ \\ \\ \\text{for} \\ n > 1\n$$\n\n::: {#a4be1402 .cell execution_count=3}\n``` {.python .cell-code}\ndef fibonacci(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n - 1) + fibonacci(n - 2)\n```\n:::\n\n\n::: {#9b9a6b9e .cell execution_count=4}\n``` {.python .cell-code}\nfibonacci_sequence = [fibonacci(n) for n in range(7)]\n\nfibonacci_sequence\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n[0, 1, 1, 2, 3, 5, 8]\n```\n:::\n:::\n\n\n::: {#934d7109 .cell execution_count=5}\n``` {.python .cell-code}\nplot_sequence(fibonacci_sequence, 7, \"Fibonacci Sequence\", \"n\", \"Fibonacci(n)\")\n```\n\n::: {.cell-output .cell-output-display}\n![](integer_sequences_files/figure-html/cell-6-output-1.png){width=802 height=528}\n:::\n:::\n\n\n### Factorial Sequence\n\nThe next sequence is **[Factorial](https://en.wikipedia.org/wiki/Factorial)**. Factorial of a positive integer is denoted by $n!$ and is the product \nto all positive integers less or equal to $n$.\nThe formula is: \n$$\nn! = n \\times (n-1) \\times (n-2) \\times \\cdots \\times 2 \\times 1\n$$\n \nFor integers $n \\geq 1$ we have the following formula: $n! = \\prod_{i=1}^{n} i$, which leads us to the following reccurence \nrelation: $n! = n \\cdot (n-1)!$. The initial condition is that $n!=1$ for $n$ equal to 1 and 0.\n\n::: {#60598aa2 .cell execution_count=6}\n``` {.python .cell-code}\ndef factorial(n):\n    if n < 2:\n        return 1\n    else:\n        return n * factorial(n - 1)\n```\n:::\n\n\n::: {#39fa5f35 .cell execution_count=7}\n``` {.python .cell-code}\nfactorial_sequence = [factorial(n) for n in range(6)]\n\nfactorial_sequence\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n[1, 1, 2, 6, 24, 120]\n```\n:::\n:::\n\n\n::: {#d0db4929 .cell execution_count=8}\n``` {.python .cell-code}\nplot_sequence(factorial_sequence, 6, \"Factorial Sequence\", \"n\", \"Factorial(n)\")\n```\n\n::: {.cell-output .cell-output-display}\n![](integer_sequences_files/figure-html/cell-9-output-1.png){width=819 height=528}\n:::\n:::\n\n\n### Padovan Sequence\n\n**[Padovan Sequence](https://en.wikipedia.org/wiki/Padovan_sequence)** is the sequence of integers with initial value given by: \n$P(0) = P(1) = P(2) = 1$.\nThe recurrence relation is defined by\n$$\nP(n) = P(n - 2) + P(n - 3)\n$$\n\n::: {#31607010 .cell execution_count=9}\n``` {.python .cell-code}\ndef padovan(n):\n    if n < 3:\n        return 1\n    else:\n        return padovan(n - 2) + padovan(n - 3)\n```\n:::\n\n\n::: {#980ba972 .cell execution_count=10}\n``` {.python .cell-code}\npadovan_sequence = [padovan(n) for n in range(6)]\n\npadovan_sequence\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n[1, 1, 1, 2, 2, 3]\n```\n:::\n:::\n\n\n::: {#9e06b010 .cell execution_count=11}\n``` {.python .cell-code}\nplot_sequence(padovan_sequence, 6, \"Padovan Sequence\", \"n\", \"Padovan(n)\")\n```\n\n::: {.cell-output .cell-output-display}\n![](integer_sequences_files/figure-html/cell-12-output-1.png){width=815 height=528}\n:::\n:::\n\n\n### Perrin Number\n\nThe reccurent formula for **[Perrin Sequence](https://en.wikipedia.org/wiki/Perrin_number)** with initial values $P(0) = 3$, $P(1) = 0$, and $P(2) = 2$ \nis defined by\n$$\nP(n) = P(n - 2) + P(n - 3)\n$$\n\n::: {#d019329b .cell execution_count=12}\n``` {.python .cell-code}\ndef perrin(n):\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return perrin(n - 2) + perrin(n - 3)\n```\n:::\n\n\n::: {#2560c9b3 .cell execution_count=13}\n``` {.python .cell-code}\nperrin_sequence = [perrin(n) for n in range(9)]\n\nperrin_sequence\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n[3, 0, 2, 3, 2, 5, 5, 7, 10]\n```\n:::\n:::\n\n\n::: {#8ce10b93 .cell execution_count=14}\n``` {.python .cell-code}\nplot_sequence(perrin_sequence, 9, \"Perrin Sequence\", \"n\", \"Perrin(n)\")\n```\n\n::: {.cell-output .cell-output-display}\n![](integer_sequences_files/figure-html/cell-15-output-1.png){width=810 height=528}\n:::\n:::\n\n\n### Sylvester's Sequence\n\nIn the **[Sylvester's sequence](https://en.wikipedia.org/wiki/Sylvester%27s_sequence)**, each element is the product of previous terms, plus one. \nDue to this reason, Sylvester's sequence is considered to have doubly exponential growth, when sequence increases a much higher rate than, say factorial sequence. \nThe initial condition for the sequence is $S_{0} = 2$. This is because the product of an empty set is $1$. The sequence is given by: \n$$\nS_{n} = 1 + \\prod_{i=0}^{n-1} s_{i}\n$$\n\nRewriting it into recurrence formula, gives:\n$$\nS_{i} = S_{i-1}\\cdot(S_{i-1} - 1) + 1\n$$\n\n::: {#9c646f88 .cell execution_count=15}\n``` {.python .cell-code}\ndef sylvester(n):\n    if n == 0:\n        return 2\n    else:\n        return sylvester(n - 1) * (sylvester(n - 1) - 1) + 1\n```\n:::\n\n\n::: {#06a07494 .cell execution_count=16}\n``` {.python .cell-code}\nsylvester_sequence = [sylvester(n) for n in range(5)]\n\nsylvester_sequence\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n[2, 3, 7, 43, 1807]\n```\n:::\n:::\n\n\n::: {#801cc9b6 .cell execution_count=17}\n``` {.python .cell-code}\nplot_sequence(sylvester_sequence, 5, \"Sylvester Sequence\", \"n\", \"Sylvester(n)\")\n```\n\n::: {.cell-output .cell-output-display}\n![](integer_sequences_files/figure-html/cell-18-output-1.png){width=827 height=528}\n:::\n:::\n\n\n### Fermat Number\n\n**[Fermat number or Fermat sequence](https://en.wikipedia.org/wiki/Fermat_number)**, named after well-known Pierre de Fermat, forms the sequence \nof the following form:\n$$\nF_{n} = 2^{2^{n}} + 1\n$$\n\nwith the condition that $n \\geq 0$. The recurrence relation is given by:\n$$\nF_{n} = (F_{n-1} - 1)^{2} + 1\n$$\n\nNote that, both formulae are valid. However, I use the first to implement it in Python.\n\n::: {#8795a13c .cell execution_count=18}\n``` {.python .cell-code}\ndef fermat(n):\n    return 2 ** (2**n) + 1\n```\n:::\n\n\n::: {#c3226149 .cell execution_count=19}\n``` {.python .cell-code}\nfermat_sequence = [fermat(n) for n in range(6)]\n\nfermat_sequence\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n[3, 5, 17, 257, 65537, 4294967297]\n```\n:::\n:::\n\n\n::: {#2b3122f4 .cell execution_count=20}\n``` {.python .cell-code}\nplot_sequence(fermat_sequence, 6, \"Fermat Sequence\", \"n\", \"Fermat(n)\")\n```\n\n::: {.cell-output .cell-output-display}\n![](integer_sequences_files/figure-html/cell-21-output-1.png){width=802 height=528}\n:::\n:::\n\n\n# Conclusion\n\nIn this post, I tried to review some integer sequences and implemented them in Python. The analysis of these sequences is a matter of another blog post. \nHowever, looking at the plots we can compare these sequences at least with their growth rate. The Fermat sequence has a pretty much higher growth rate than other sequences. Calculating $n^{th}$ term of these sequences can be quite challenging.\n\n\n#### References\n* [Sequences](https://www.mathsisfun.com/algebra/sequences-series.html)\n* [Sequence](https://en.wikipedia.org/wiki/Sequence)\n* [List of OEIS sequences](https://en.wikipedia.org/wiki/List_of_OEIS_sequences)\n\n",
    "supporting": [
      "integer_sequences_files"
    ],
    "filters": [],
    "includes": {}
  }
}