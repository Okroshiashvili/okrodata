{
  "hash": "0879925c482a7368139b894a232f4942",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Lost in Pandas - Part 1\"\nauthor: \"Nodar Okroshiashvili\"\ndate: \"2020-04-10\"\ndate-modified: \"2025-09-29\"\ncategories: [Data Science]\ntags: [Pandas, Data Analysis]\n\nabstract: |\n    Pandas tips and tricks that I found useful in my data science journey.\n\nimage: \"image.jpg\"\n---\n\n# Introduction\n\nMany have been told and written about Pandas and its capabilities. I could not imagine data scientist or data analyst who had not heard about Pandas or had not used it at least once. We all use it. Every day, every week. It does not matter how many times. It's a great tool. I use it all the time when I want to do data analysis, either it is simple calculations or complex data transformations, and it surprises me. Pandas is so simple in its form. However, imagine, how much you can do with some simple method chaining.\n\nSaying all of these, this blog aims to share my experience and amazment with Pandas.\n\n## Problem Statement\n\nWe have data. This data comes from the HR department of the company. The data contains two columns, company name, and information about its employees. Each row of the employee information column is a list of lists. The lists inside the outer list can be duplicated. It also can have duplicate values, and inner lists have at most two values.\n\n> Disclaimer:  Any name, phone, email, and the title is a pure coincidence. Data is random and fake.\n\nHere is our data.\n\n::: {#ca395472 .cell execution_count=1}\n``` {.python .cell-code}\nfrom collections import defaultdict\n\nimport pandas as pd\nimport numpy as np\n```\n:::\n\n\n::: {#5787efc4 .cell execution_count=2}\n``` {.python .cell-code}\ndata = {\n    \"company_name\": [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"],\n    \"info\": [\n        [[\"Name\", \"David Jones\"], [\"Title\", \"CEO\"], [\"Phone\", \"207-685-1626\"], [\"Email\", \"djones@example.org\"]],\n        [\n            [\"Name\", \"Kate Brown\"],\n            [\"Title\", \"Senior Lawyer\"],\n            [\"Phone\", \"316-978-7791\"],\n            [\"Email\", \"Kate.Brown@example.edu\"],\n            [\"Name\", \"Darin White\"],\n            [\"Title\", \"Associate Vice President\"],\n            [\"Phone\", \"316-978-3887\"],\n            [\"Email\", \"Darin.White@example.edu\"],\n        ],\n        [\n            [\"Name\", \"Scott Lamb\"],\n            [\"Title\", \"Actuary\"],\n            [\"Phone\", \"316-978-3804\"],\n            [\"Email\", \"scott.lamb@example.edu\"],\n            [\"Name\", \"Scott Lamb\"],\n            [\"Title\", \"Senior Officer\"],\n            [\"Title\", \"Application Developer\"],\n            [\"Title\", \"Blockchain Architect\"],\n            [\"Title\", \"Director of External Affairs\"],\n            [\"Name\", \"Scott\"],\n            [\"Name\", \"Scott\"],\n            [\"Title\", \"Director of Medicine\"],\n            [\"Title\", \"Product Owner\"],\n            [\"Name\", \"Mike\"],\n            [\"Title\", \"Domain Expert\"],\n            [\"Title\", \"Growth Hacker\"],\n            [\"Title\", \"Engineering Head\"],\n            [\"Title\", \"Event Manager\"],\n            [\"Name\", \"Joe\"],\n            [\"Name\", \"Mike\"],\n            [\"Title\", \"Fundraising\"],\n            [\"Title\", \"VP of Customers\"],\n            [\"Name\", \"Mike\"],\n            [\"Title\", \"Venture Capital Analyst\"],\n            [\"Title\", \"UX Designer\"],\n            [\"Name\", \"Mike\"],\n            [\"Name\", \"Susan\"],\n            [\"Name\", \"Bryan\"],\n            [\"Name\", \"Mia\"],\n            [\"Title\", \"Songwriter\"],\n        ],\n        [\n            [\"Name\", \"Rose Smith Rose Smith\"],\n            [\"Title\", \"Vice President\"],\n            [\"Title\", \"Finance and Operations Head\"],\n            [\"Phone\", \"316-978-3810\"],\n            [\"Email\", \"rose.smith@example.edu\"],\n            [\"Name\", \"Rose Smith\"],\n            [\"Title\", \"Foundation\"],\n            [\"Name\", \"Susan\"],\n            [\"Title\", \"Foundation\"],\n            [\"Title\", \"Accountant\"],\n            [\"Title\", \"Accountant\"],\n            [\"Title\", \"Executive\"],\n            [\"Title\", \"Director\"],\n            [\"Title\", \"Executive\"],\n            [\"Name\", \"Ray\"],\n            [\"Title\", \"Strategic Planning\"],\n            [\"Title\", \"Financial Analyst\"],\n            [\"Title\", \"Foundation\"],\n            [\"Title\", \"Foundation\"],\n            [\"Name\", \"Susan\"],\n            [\"Title\", \"member of the board\"],\n            [\"Title\", \"board of directors\"],\n            [\"Title\", \"president\"],\n            [\"Title\", \"board of directors\"],\n        ],\n        [\n            [\"Name\", \"Carl Clark\"],\n            [\"Title\", \"Chief \"],\n            [\"Title\", \"Operating Officer\"],\n            [\"Title\", \"PhD\"],\n            [\"Phone\", \"413-534-2745\"],\n            [\"Email\", \"Clark_Carl@example.com\"],\n        ],\n        [\n            [\"Title\", \"Board Member\"],\n            [\"Name\", \"Taylor Garcia\"],\n            [\"Phone\", \"307-733-2164\"],\n            [\"Phone\", \"307-733-4568\"],\n            [\"Email\", \"Garcia@example.org\"],\n        ],\n    ],\n}\n```\n:::\n\n\nLet convert this dictionary into Pandas DataFrame and see what data we have.\n\n::: {#7bc23a8b .cell execution_count=3}\n``` {.python .cell-code}\ndf = pd.DataFrame(data)\n\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>company_name</th>\n      <th>info</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>A</td>\n      <td>[[Name, David Jones], [Title, CEO], [Phone, 20...</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>B</td>\n      <td>[[Name, Kate Brown], [Title, Senior Lawyer], [...</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>C</td>\n      <td>[[Name, Scott Lamb], [Title, Actuary], [Phone,...</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>D</td>\n      <td>[[Name, Rose Smith Rose Smith], [Title, Vice P...</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>E</td>\n      <td>[[Name, Carl Clark], [Title, Chief ], [Title, ...</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe see that the first column seems okay, but the second one not. Here we have one big list containing smaller two-element lists.\n\n::: {#a0bd4879 .cell execution_count=4}\n``` {.python .cell-code}\ndf[\"info\"].iloc[2]\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n[['Name', 'Scott Lamb'],\n ['Title', 'Actuary'],\n ['Phone', '316-978-3804'],\n ['Email', 'scott.lamb@example.edu'],\n ['Name', 'Scott Lamb'],\n ['Title', 'Senior Officer'],\n ['Title', 'Application Developer'],\n ['Title', 'Blockchain Architect'],\n ['Title', 'Director of External Affairs'],\n ['Name', 'Scott'],\n ['Name', 'Scott'],\n ['Title', 'Director of Medicine'],\n ['Title', 'Product Owner'],\n ['Name', 'Mike'],\n ['Title', 'Domain Expert'],\n ['Title', 'Growth Hacker'],\n ['Title', 'Engineering Head'],\n ['Title', 'Event Manager'],\n ['Name', 'Joe'],\n ['Name', 'Mike'],\n ['Title', 'Fundraising'],\n ['Title', 'VP of Customers'],\n ['Name', 'Mike'],\n ['Title', 'Venture Capital Analyst'],\n ['Title', 'UX Designer'],\n ['Name', 'Mike'],\n ['Name', 'Susan'],\n ['Name', 'Bryan'],\n ['Name', 'Mia'],\n ['Title', 'Songwriter']]\n```\n:::\n:::\n\n\nAs we figured out the data structure, let define the aim.\n\n**We need to unpack lists from the second column and flatten them in tabular format in the way to preserve the order.\nMeaning that, from the above example, ```Scott Lamb``` has to have title ```Actuary``` and not other titles are allowed.\nLong story short, we need to flatten list of list and make proper DataFrame from it.**\n\n## How I approached this problem\n\nThe first idea that came to my mind was to use Pandas DataFrame ```.explode()``` method to unpack list of lists,\nwhich returned lists containing two elements. After that, I extracted these two elements into two different columns.\n\n::: {#a2843efa .cell execution_count=5}\n``` {.python .cell-code}\ndf_exploded = df.explode(\"info\")\n\ndf_exploded.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>company_name</th>\n      <th>info</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>A</td>\n      <td>[Name, David Jones]</td>\n    </tr>\n    <tr>\n      <th>0</th>\n      <td>A</td>\n      <td>[Title, CEO]</td>\n    </tr>\n    <tr>\n      <th>0</th>\n      <td>A</td>\n      <td>[Phone, 207-685-1626]</td>\n    </tr>\n    <tr>\n      <th>0</th>\n      <td>A</td>\n      <td>[Email, djones@example.org]</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>B</td>\n      <td>[Name, Kate Brown]</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#465b7928 .cell execution_count=6}\n``` {.python .cell-code}\n# Add two new columns\ndf_exploded.loc[:, \"tag\"] = df_exploded[\"info\"].map(lambda x: x[0])\n\ndf_exploded.loc[:, \"result\"] = df_exploded[\"info\"].map(lambda x: x[1])\n\ndf_exploded.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>company_name</th>\n      <th>info</th>\n      <th>tag</th>\n      <th>result</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>A</td>\n      <td>[Name, David Jones]</td>\n      <td>Name</td>\n      <td>David Jones</td>\n    </tr>\n    <tr>\n      <th>0</th>\n      <td>A</td>\n      <td>[Title, CEO]</td>\n      <td>Title</td>\n      <td>CEO</td>\n    </tr>\n    <tr>\n      <th>0</th>\n      <td>A</td>\n      <td>[Phone, 207-685-1626]</td>\n      <td>Phone</td>\n      <td>207-685-1626</td>\n    </tr>\n    <tr>\n      <th>0</th>\n      <td>A</td>\n      <td>[Email, djones@example.org]</td>\n      <td>Email</td>\n      <td>djones@example.org</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>B</td>\n      <td>[Name, Kate Brown]</td>\n      <td>Name</td>\n      <td>Kate Brown</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nDespite unpacking the list of lists, that is not the format I wanted. So, I need to do an extra transformation.\n\n::: {#96347cfd .cell execution_count=7}\n``` {.python .cell-code}\ndf_exploded_final = (\n    df_exploded.groupby([\"company_name\", \"tag\"])[\"result\"]\n    .apply(lambda x: pd.Series(x.values))\n    .unstack(1)\n    .reset_index()\n    .drop([\"level_1\"], axis=1)\n)\n\ndf_exploded_final.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>tag</th>\n      <th>company_name</th>\n      <th>Email</th>\n      <th>Name</th>\n      <th>Phone</th>\n      <th>Title</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>A</td>\n      <td>djones@example.org</td>\n      <td>David Jones</td>\n      <td>207-685-1626</td>\n      <td>CEO</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>B</td>\n      <td>Kate.Brown@example.edu</td>\n      <td>Kate Brown</td>\n      <td>316-978-7791</td>\n      <td>Senior Lawyer</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>B</td>\n      <td>Darin.White@example.edu</td>\n      <td>Darin White</td>\n      <td>316-978-3887</td>\n      <td>Associate Vice President</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>C</td>\n      <td>scott.lamb@example.edu</td>\n      <td>Scott Lamb</td>\n      <td>316-978-3804</td>\n      <td>Actuary</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>C</td>\n      <td>NaN</td>\n      <td>Scott Lamb</td>\n      <td>NaN</td>\n      <td>Senior Officer</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nIt seems we did a good job. However, this approach is prone to errors. Namely, it does not preserve the order\nof the list values and may assign a different email to a different person. That was not what I need.\n\nSo, I decided to use another way to solve this problem. Notably, as the data contained millions of rows,\nit seemed impossible to be too precise, but I wanted to reduce the error of non-matching cases. To achieve this, I iterated over the values of ```info``` column and converted it to dict of lists, where keys are tags (identifiers) and values are actual employee information.\n\n::: {#4544a058 .cell execution_count=8}\n``` {.python .cell-code}\nout = []\n\nfor x in df[\"info\"].tolist():\n    groups = defaultdict(list)\n    for g, v in x:\n        groups[g].append(v)\n    out.append(dict(groups))\n\n\ndf.loc[:, \"new_info\"] = out\n\ndf[\"new_info\"].iloc[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n{'Name': ['David Jones'],\n 'Title': ['CEO'],\n 'Phone': ['207-685-1626'],\n 'Email': ['djones@example.org']}\n```\n:::\n:::\n\n\nThat's a step forward. After this, I was interested in counting the values for each key in dicts for each row.\nI made small changes in the above code and applied it to the ```new_info``` column.\n\n::: {#1db7a560 .cell execution_count=9}\n``` {.python .cell-code}\nout = []\n\nfor x in df[\"new_info\"]:\n    groups = defaultdict(int)\n    for g, v in x.items():\n        groups[g] = len(list(filter(None, v)))\n    out.append(dict(groups))\n\n\ndf.loc[:, \"new_info_stats\"] = out\n\ndf[\"new_info_stats\"].iloc[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n{'Name': 1, 'Title': 1, 'Phone': 1, 'Email': 1}\n```\n:::\n:::\n\n\nAs we calculated value counts for each dict, now we need to add three helper columns to the dataset for further usage.\nThese helper columns will help to differentiate matching cases and non-matching cases.\n\n::: {#337387e1 .cell execution_count=10}\n``` {.python .cell-code}\ndf[\"_max\"] = df[\"new_info_stats\"].apply(lambda x: max(x.values()))\n\ndf[\"_min\"] = df[\"new_info_stats\"].apply(lambda x: min(x.values()))\n\ndf.loc[:, \"max_equal_min\"] = pd.Series(np.where((df[\"_max\"] == df[\"_min\"]), 1, 0))\n```\n:::\n\n\nThe column ```max_equal_min``` is a dummy variable and helps us to differentiate matching and non-matching cases.\nThe value 1 indicates we have a matching case and value 0 - non-matching case. According to this column,\nI split data into two parts. The first only contains matching examples, and the second will have only non-matching cases.\n\n::: {#f8f55654 .cell execution_count=11}\n``` {.python .cell-code}\ndf_first = df[df[\"max_equal_min\"] > 0].reset_index(drop=True)\n\ndf_second = df[df[\"max_equal_min\"] == 0].reset_index(drop=True)\n```\n:::\n\n\nThe pre-processing of the first DataFrame is over and is ready to flatten. To do so, I iterate over\n```new_info``` column and transform each row into Pandas DataFrame. After this step, data will be flat.\n\n::: {#1a433535 .cell execution_count=12}\n``` {.python .cell-code}\nnew_data = []\n\nfor j in df_first[\"new_info\"]:\n    new_data.append(pd.DataFrame(j))\n\n\ndf_first_final_i = (\n    pd.concat(new_data, axis=0, sort=False).drop_duplicates().dropna(subset=[\"Name\"]).reset_index(drop=True)\n)\n\ndf_first_final_i.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Title</th>\n      <th>Phone</th>\n      <th>Email</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>David Jones</td>\n      <td>CEO</td>\n      <td>207-685-1626</td>\n      <td>djones@example.org</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Kate Brown</td>\n      <td>Senior Lawyer</td>\n      <td>316-978-7791</td>\n      <td>Kate.Brown@example.edu</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Darin White</td>\n      <td>Associate Vice President</td>\n      <td>316-978-3887</td>\n      <td>Darin.White@example.edu</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWoohoo, it works! However, imagine having millions of rows how slow this approach will be.\nFor this reason, I tried another method and found it much faster. Here it is.\n\n::: {#db195fca .cell execution_count=13}\n``` {.python .cell-code}\ndf_first_final_ii = (\n    df_first[\"new_info\"].apply(pd.Series).apply(lambda x: x.explode()).drop_duplicates().reset_index(drop=True)\n)\n\ndf_first_final_ii.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Title</th>\n      <th>Phone</th>\n      <th>Email</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>David Jones</td>\n      <td>CEO</td>\n      <td>207-685-1626</td>\n      <td>djones@example.org</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Kate Brown</td>\n      <td>Senior Lawyer</td>\n      <td>316-978-7791</td>\n      <td>Kate.Brown@example.edu</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Darin White</td>\n      <td>Associate Vice President</td>\n      <td>316-978-3887</td>\n      <td>Darin.White@example.edu</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nFaster and cleaner solution. But, what about the second DataFrame? It turned out that the above solution\ndid not fit the second DataFrame and gave me an error. The error was ```ValueError: cannot reindex from a duplicate axis```. Before finding the solution for this error, let take a look at the data.\n\n::: {#2c1a7514 .cell execution_count=14}\n``` {.python .cell-code}\ndf_second.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>company_name</th>\n      <th>info</th>\n      <th>new_info</th>\n      <th>new_info_stats</th>\n      <th>_max</th>\n      <th>_min</th>\n      <th>max_equal_min</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>C</td>\n      <td>[[Name, Scott Lamb], [Title, Actuary], [Phone,...</td>\n      <td>{'Name': ['Scott Lamb', 'Scott Lamb', 'Scott',...</td>\n      <td>{'Name': 12, 'Title': 16, 'Phone': 1, 'Email': 1}</td>\n      <td>16</td>\n      <td>1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>D</td>\n      <td>[[Name, Rose Smith Rose Smith], [Title, Vice P...</td>\n      <td>{'Name': ['Rose Smith Rose Smith', 'Rose Smith...</td>\n      <td>{'Name': 5, 'Title': 17, 'Phone': 1, 'Email': 1}</td>\n      <td>17</td>\n      <td>1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>E</td>\n      <td>[[Name, Carl Clark], [Title, Chief ], [Title, ...</td>\n      <td>{'Name': ['Carl Clark'], 'Title': ['Chief ', '...</td>\n      <td>{'Name': 1, 'Title': 3, 'Phone': 1, 'Email': 1}</td>\n      <td>3</td>\n      <td>1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>F</td>\n      <td>[[Title, Board Member], [Name, Taylor Garcia],...</td>\n      <td>{'Title': ['Board Member'], 'Name': ['Taylor G...</td>\n      <td>{'Title': 1, 'Name': 1, 'Phone': 2, 'Email': 1}</td>\n      <td>2</td>\n      <td>1</td>\n      <td>0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nIn the second and third row, we have one ```Name``` and three ```Title``` and two ```Phone```,\nrespectively, for the ```new_info_stats``` column. This may be due to the data entry or extraction reason.\nNot 100% sure that this is the case, but the likelihood is very high. So, we have to handle this problem properly.\nOne solution is to concatenate strings for the values of ```Title``` and ```Phone``` keys.\n\n::: {#7c74afec .cell execution_count=15}\n``` {.python .cell-code}\ndef process_info(record: dict) -> dict:\n    if (\n        len(record.keys()) == 4\n        and len(record.get(\"Name\")) == 1\n        and len(record.get(\"Title\")) > 1\n        and len(record.get(\"Email\")) == 1\n        and len(record.get(\"Phone\")) == 1\n    ):\n        record[\"Title\"] = [\" \".join(record.get(\"Title\"))]\n\n    elif (\n        len(record.keys()) == 4\n        and len(record.get(\"Name\")) == 1\n        and len(record.get(\"Title\")) == 1\n        and len(record.get(\"Email\")) > 1\n        and len(record.get(\"Phone\")) == 1\n    ):\n        record[\"Email\"] = [\",\".join(record.get(\"Email\"))]\n\n    elif (\n        len(record.keys()) == 4\n        and len(record.get(\"Name\")) == 1\n        and len(record.get(\"Title\")) == 1\n        and len(record.get(\"Email\")) == 1\n        and len(record.get(\"Phone\")) > 1\n    ):\n        record[\"Phone\"] = [\",\".join(record.get(\"Phone\"))]\n\n    else:\n        pass\n    return record\n\n\ndf_second[\"new_info\"] = df_second[\"new_info\"].apply(process_info)\n```\n:::\n\n\nThis is a simple logic to check if we are correctly concatenating string. After applying this function, the second DataFrame is ready to flatten. As I mentioned above the good old method did not give me the desired result for this case and then I came up to the following:\n\n::: {#4ec74246 .cell execution_count=16}\n``` {.python .cell-code}\ndef flatten(df, column):\n    data = []\n    for i in df[column]:\n        data.append(pd.DataFrame(dict([(k, pd.Series(v)) for k, v in i.items()])))\n\n    new_df = (\n        pd.concat(data, axis=0, sort=False)\n        .drop_duplicates()\n        .dropna(subset=[\"Name\"])\n        .drop_duplicates(subset=[\"Name\", \"Title\", \"Phone\", \"Email\"])\n        .reset_index(drop=True)\n    )\n\n    return new_df\n\n\ndf_second_final = flatten(df_second, \"new_info\")\n\ndf_second_final.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Title</th>\n      <th>Phone</th>\n      <th>Email</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Scott Lamb</td>\n      <td>Actuary</td>\n      <td>316-978-3804</td>\n      <td>scott.lamb@example.edu</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Scott Lamb</td>\n      <td>Senior Officer</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Scott</td>\n      <td>Application Developer</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Scott</td>\n      <td>Blockchain Architect</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Mike</td>\n      <td>Director of External Affairs</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nApplied this function to the second DataFrame flattened it, and combining first and second DataFrames will give the final result.\n\n\n# Conclusion\n\nTo sum up, that was only a tiny part of this data pre-processing process.\nHowever, it was a great journey and lots to learn. What do you think? Did you find a more elegant solution? Please share it in the comments.\n\n",
    "supporting": [
      "pandas_tips_and_tricks_1_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js\" integrity=\"sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\" integrity=\"sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}